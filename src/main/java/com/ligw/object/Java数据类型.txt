JAVA关键字
    数据类型：byte short int long float double char boolean class interface enum void
    定义数据类型值：true false null
    定义流程控制：if else switch case default while do for break continue return
    定义访问权限修饰符：private protected public
    定义类 函数 变量修饰符：abstract final static synchronized
    定义类与类之间关系：extends implements
    定义建立实例及引用实例判断实例：new this super instanceof
    用于异常处理：try catch finally throw throws
    用于包：package import
    其他修饰符：native strictfp transient volatile assert

JAVA数据类型
    基础数据类型
        ·数值型
            -整数类型
                byte:1byte 8bit -128至127 2^8
                short:2byte   -32768至32767
                int:4byte -2^31至2^31-1    -2147483648至2147483647 约21亿
                long：8byte    2^63至2^63-1 约9.22337203685E18(比long还大的是BigDecimina BigInteger)
            -浮点类型
                单精度类型(float) 4byte +-3.403E38
                    1bit(符号位 0表示正数,1表示负数)+8bits(指数位 底数是2)+23bits(尾数位)
                双精度类型(double) 8byte +-1.798E308
                    1bit(符号位)+11bits(指数位)+52bits(尾数位)
        字符型(char) 2byte
        布尔型(boolean) 1bit
    引用数据类型
        类(Class)（包含字符串类 String）
        接口(interface)
        数组([])

浮点数保存原理>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    浮点数保存的字节格式如下：
    地址 +0 +1 +2 +3
    内容 SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM

    这里
        S 代表符号位，1是负，0是正
        E 偏移127的幂，二进制阶码=(EEEEEEEE)-127。
        M 24位的尾数保存在23位中，只存储23位，最高位固定为1。此方法用最较少的位数实现了较高的有效位数，提高了精度。

    零是一个特定值，幂是0 尾数也是0。

    浮点数-12.5作为一个十六进制数0xC1480000保存在存储区中，这个值如下：
    地址 +0 +1 +2 +3
    内容0xC1 0x48 0x00 0x00

    浮点数和十六进制等效保存值之间的转换相当简单。下面的例子说明上面的值-12.5如何转换。
    浮点保存值不是一个直接的格式，要转换为一个浮点数，位必须按上面的浮点数保存格式表所列的那样分开，例如：

    地址 +0 +1 +2 +3
    格式 SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM
    二进制 11000001 01001000 00000000 00000000
    十六进制 C1 48 00 00

    从这个例子可以得到下面的信息：
    符号位是1 表示一个负数
    幂是二进制10000010或十进制130，130减去127是3，就是实际的幂。
    尾数是后面的二进制数10010000000000000000000

    在尾数的左边有一个省略的小数点和1,这个1在浮点数的保存中经常省略,加上一个1和小数点到尾数的开头,得到尾数值如下:
    1.10010000000000000000000

    接着,根据指数调整尾数.一个负的指数向左移动小数点.一个正的指数向右移动小数点.因为指数是3,尾数调整如下:
    1100.10000000000000000000

    结果是一个二进制浮点数，小数点左边的二进制数代表所处位置的2的幂，例如：1100表示(1*2^3)+(1*2^2)+(0*2^1)+(0*2^0)=12。
    小数点的右边也代表所处位置的2的幂，只是幂是负的。例如：.100...表示(1*2^(-1))+(0*2^(-2))+(0*2^(-2))...=0.5。
    这些值的和是12.5。因为设置的符号位表示这数是负的，因此十六进制值0xC1480000表示-12.5。


float的指数范围为-2^7~2^7-1(即-128~127)，而double的指数范围为-2^10~2^10-1(即-1024~1023)，并且指数位是补码的形式来划分的。
其中负指数决定了浮点数所能表达的绝对值最小的数；而正指数决定了浮点数所能表达的绝对值最大的数，也即决定了浮点数的取值范围。
float和double的精度是由尾数的位数来决定的。浮点数在内存中是按科学计数法来存储的，其整数部分始终是一个隐含着的“1”，由于它是不变的，故不能对精度造成影响
float：2^23 = 8388608，一共七位，这意味着最多能有7位有效数字，但绝对能保证的为6位，也即float的精度为6~7位有效数字；
double：2^52 = 4503599627370496，一共16位，同理，double的精度为15~16位。

浮点数存在舍入误差，很多书字不能精确表示。如果需要进行不产生舍入误差的精确数字计算，需要使用BigDecimal类
最好避免比较中使用浮点数
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

2^0 1
2^1 2
2^2 4
2^3 8
2^4 16
2^7 128
2^8 256
2^15    32 768
2^16    65 536
2^31    2 147 483 648
2^32    4 294 967 296
2^63    9.22337203685E18
2^64    1.84467440737E19

用单引号表示字符 双引号为字符串
char类型是用来表示在unicode编码表中的字符
unicode编码被设计用来处理各种语言的所有文字，占用2个字符，可允许有65536个字符
Java 语言中还允许使用转义字符'\' 来将其后的字符转变为其他含义
char 是在0-65536范围 ， 运算时直接当做是整数来运算 可以把0-65536之间的整数直接转型为char char c = (char)99;//强制转型 -> 扩展 循环打印a-z
Unicode对照表：https://baike.baidu.com/item/ASCII/309296

基础类型相互转化
    自动转型：容量小的类型可以自动转为容量大的类型
        byte -> short -> int
                char  -> int
                         int -> long -(可能损失精度)-> double
                                     -(可能损失精度)-> float -> double
                         int -> double
                         int -(精度可能损失)-> float -> double

    强制转型 ：有可能造成精度境地或溢出  当一种类型强制转换成另一种类型而又超出了目标类型的表示范围，就会被阶段成为一个完全不同的值
    运算时结果会向容量大的类型提升
    运算结果溢出时会变成一个无意义的值 如int类型溢出时会变成负值

    例：计算一个人70年心跳次数
        long l = 70L*60*24*365*70;
        //若不把第一个70转化成long类型 计算结果则会溢出


进制计算
    二进制(Binary):
    java中0b开头表示二进制数 可用下划线分割 下划线分隔符同样适用于十进制

反码
补码

数组
    数组默认初始化：数组元素相当于对象的成员变量，默认值跟成员变量的规则一样

Java中除了基本类型外的变量类型都称为引用类型，java中的对象是通过引用（reference）对其操作的
    java中默认初始化：数值：0,,0.0  char:\u0000 boolean:false 引用类型：null

内存分析：
    栈：存放局部变量
    堆：存放new出来的对象
    方法区：存放 类的代码 static变量 常量池等
