OSI 7层参考模型
应用层、表示层、会话层、传输控制层、网络层、链路层、物理层  

TCP/IP协议
应用层、传输控制层、网络层、链路层、物理层  
![TCP/IP协议模型](http://resource.cmbi.info/1a2ab07f-1461-4e41-8054-9d94cdecb9fb)

###应用层
shell演示: 1.向内核发送建立连接请求(三次握手) 2.发送数据(数据传输) 3.拿到响应(数据传输)（4.关闭连接(四次分手)）
```shell
# 与百度建立连接 exec:重定向 <>代表输入输出两个方向
exec 8<> /dev/tcp/www.baidu.com/80
# echo:打印 \n间隔请求头、请求体 空格用来做命令切割
#【协议：请求方法 、协议、协议版本 \n】【请求头(后面两个换行)：\n\n】 【请求体：】
# >&代表重定向，输出到8  8代表前面与baidu建立起来的连接
echo -e "GET / HTTP/1.0\n" >& 8
# cat:读取 <&代表从8读取
cat <& 8
# 关掉8这个链接
exec 8<& -
# 返回体结构
# 【协议：协议版本 状态code 状态\n】 【响应头(后面两个换行): \n\n】 【响应体：】
# nc：比telnet高级的设置路由命令
nc www.baidu.com 80
```
软件工程学的封装结果: webServer


###传输(包)控制(连接)层(协议:UDP/TCP)  
TCP协议:面向连接的可靠的传输协议  
**连接**
![三次握手建立连接](http://resource.cmbi.info/8982be50-7457-4374-97e4-3601d9770e41)  
第三次握手的必要性：服务端也必须收到确认响应  
socket(连接建立后在内核中存储socket信息，后面基于socket传输数据 socket的唯一性)：四元组：[ip+host ip+host]  
port(端口号)的取值范围：65535(port分配原则1024？？？？)  
![四次分手](http://resource.cmbi.info/158ea83e-81bd-48ec-9657-621c73b85a03)  
shell演示：
```shell script
# tcpdump：抓包并打印
tcpdump -nn -i eth0 port 80
# 建立连接,tcpdump有包可抓
curl www.baidu.com
```
三次握手建立连接->http传输数据->四次分手断开连接是一个线性过程
> 1. 应用层申请建立连接->内核(应用层阻塞)
> 2. 内核-传输控制层准备握手的第一个包(控制包)->网络层(传输控制层阻塞)
> 3. 网络层(ip)：选择从哪个网卡哪个端口出去(找到(下一跳)网关地址)->向链路层请求网关mac地址(网络层阻塞)
> 4. 链路层:绑定mac节点->物理层
> 5. 物理层：把包发出去  
> .....  
> 完成第一次握手  
> ....  
> 不断发包收包，循环往复完成三次握手、资源开辟、数据传输、四次分手、资源释放    

shell
```shell script
# 查看网络状态(socket信息)
netstat -natp
```
###网关层(IP)
```shell script
# 查看0号网卡的配置
vi /etc/sysconfig/network-script/ifcfg-eth0
# ipV4地址，为点跟字节组成，两点之间是一个byte(字节)(8bit)表示的无符号十进制数(范围：0-255)。ip代表计算机编号
# IPADDR = 192.168.150.8
# 掩码，ip与掩码做二进制按位与运算，可得到网络号(网络目标)(192.168.150.0)
# NETMASK = 255.255.255.0
# 网关
# GATEWAY = 192.168.150.2

# 路由表(支持下一跳)
route -n
# 网络目标         网络掩码          网关           接口          跃点数
# 0.0.0.0         0.0.0.0          192.168.1.1    192.168.1.7  35
# 127.0.0.0       255.0.0.0        0.0.0.0        127.0.0.1    331
# 127.0.0.1       255.255.255.255  0.0.0.0        127.0.0.1    331  
# 127.255.255.255 255.255.255.255  0.0.0.0        127.0.0.1    331
# 192.168.1.0     255.255.255.0    0.0.0.0        192.168.1.7  291
# 192.168.1.7     255.255.255.255  0.0.0.0        192.168.1.7  291
# 192.168.1.255   255.255.255.255  0.0.0.0        192.168.1.7  291
# 224.0.0.0       240.0.0.0        0.0.0.0        127.0.0.1    331
# 网络目标:主机直连的局域网
# 网关(下一跳)：0.0.0.0表示与目标主机直连,连接不需要中间人。
# 目标IP地址(www.a.shifen.com [14.215.177.39])与路由表中每一条的掩码做二进制的按位与,
# 若得到目标与该条网络目标不一致则丢弃该条，继续计算路由表下一条记录。
# 若得到的目标与该条目的目标网络一致，则把数据包交给下一跳(该条目录的路由器网关)
``` 
**路由表的条目是怎么生成的：** 
第一条是通过网卡配置文件(ip/掩码)计算得来的，第二条是依据GATEWAY生成的(默认网关)。  

**数据包的目标IP地址应该放下一跳的IP地址还是原始IP地址?**
原始IP地址。链路层+映射表：在数据包上套下一跳的mac地址，交给交换机。下一条的路由收到包后打开发现目标IP不是自己，再做一次路由表运算，
套上对应的下一跳的mac地址交给交换机 


###链路层
```shell script
# 显示网关与mac地址的对应关系
arp
# 如果链路层不知到网关的mac地址，链路层会发一个arp广播（ping的包是icmp）
tcpdump -nn -i eth0 port 80 or arp
# 打印网关与mac地址映射表
arp -a
# 删除网关与mac地址映射表
arp -d
```