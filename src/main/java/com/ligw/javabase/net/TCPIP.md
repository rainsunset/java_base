OSI 7层参考模型|TCP/IP概念模型|关键词|。。。
---|---|---|---
应用层|应用层|HTTP、TFTP、SNMP、FTP、SMTP、DNS、telnet|
表示层|--|--|数据格式化、代码转换、数据集艾米
会话层|--|--|解除或建立与别的节点的联系
传输控制层|传输控制层|TCP、UDP|流量控制、数据分割、排序
网络层|网络层|IP|路由器
链路层|链路层|--|交换机
物理层|物理层|ISO02110、。。。|网卡；物理设备标准、传输比特流

TCP/IP协议模型  
应用层、传输控制层、网络层、链路层、物理层  
![TCP/IP协议模型](http://resource.cmbi.info/1a2ab07f-1461-4e41-8054-9d94cdecb9fb)


###应用层
shell演示: 1.向内核发送建立连接请求(三次握手) 2.发送数据(数据传输) 3.拿到响应(数据传输)（4.关闭连接(四次分手)）
```shell
# 与百度建立连接 exec:重定向 <>代表输入输出两个方向
exec 8<> /dev/tcp/www.baidu.com/80
# echo:打印 \n间隔请求头、请求体 空格用来做命令切割
#【协议：请求方法 、协议、协议版本 \n】【请求头(后面两个换行)：\n\n】 【请求体：】
# >&代表重定向，输出到8  8代表前面与baidu建立起来的连接
echo -e "GET / HTTP/1.0\n" >& 8
# cat:读取 <&代表从8读取
cat <& 8
# 关掉8这个链接
exec 8<& -
# 返回体结构
# 【协议：协议版本 状态code 状态\n】 【响应头(后面两个换行): \n\n】 【响应体：】
# nc：比telnet高级的设置路由命令
nc www.baidu.com 80
```
软件工程学的封装结果: webServer


###传输(包)控制(连接)层(协议:UDP/TCP)  
**TCP协议:**  
> 是什么: 面向连接的可靠的基于字节流的传输层通信协议  
> 作用: 将应用层的数据流(依据MTU限制)分割成报文段(通过网络IP层)发送给目标节点的TCP层  
> 数据包都有序号(SeqNo)，对方收到则发送ACK确认，若(在RTT时间内)未收到确认，则会重传  
> 适应"校验和"来检验数据在传输过程中是否有误  

**连接**
![三次握手建立连接](http://resource.cmbi.info/8982be50-7457-4374-97e4-3601d9770e41)  
第三次握手的必要性：服务端也必须收到确认响应  
socket(连接建立后在内核中存储socket信息，后面基于socket传输数据 socket的唯一性)：四元组：[ip+host ip+host]  
port(端口号)的取值范围：65535(port分配原则1024？？？？)  
![四次分手](http://resource.cmbi.info/158ea83e-81bd-48ec-9657-621c73b85a03)  
shell演示：
```shell script
# tcpdump：抓包并打印
tcpdump -nn -i eth0 port 80
# 建立连接,tcpdump有包可抓
curl www.baidu.com
```

**TCP报文头**  

字节位数|2|2|4|4|1|1|1|2|2|2|4
---|---|---|---|---|---|---|---|---|---|---|---
内容|source port|destination port|seq Number|ACK Number|offset|保留域|TCP Flags|windows|checkSUM(校验和)|Urgert Pointer|TCP Options
**checkSUM:** 是对TCP整个的报文段(包括TCP头部和TCP数据以16位计算所得，由发送端计算和存储并由接收端验证)

**TCP Flags**  
> URG:紧急指针标志（1表示紧急指针有效 0表示忽略紧急指针）  
> **ACK:确认序号标志** （1表示确认号有效 0表示报文中不含确认信息，忽略确认号字段）  
> PSH:push标志（1表示为带有push标志的数据，接收方接收到带该标志的报文段后应该将这个报文段交给应用程序，而不是在缓冲区排队）  
> RST:重置连接标志（用于重置由于主机崩溃或其他原因出现的错误的连接，或用于拒绝非法的报文段和拒绝连接请求）  
> **SYN:同步序列号**（用于建立连接过程 SYN为1且ACK为0表示该数据段没有使用捎带的确认域 SYN为1且ACK为1表示...）    
> **FIN:finish标志**（用于释放连接 为1时表示数据发送放已经没有数据发送了）  


三次握手建立连接->http传输数据->四次分手断开连接是一个线性过程
> 1. 应用层申请建立连接->内核(应用层阻塞)
> 2. 内核-传输控制层准备握手的第一个包(控制包)->网络层(传输控制层阻塞)
> 3. 网络层(ip)：选择从哪个网卡哪个端口出去(找到(下一跳)网关地址)->向链路层请求网关mac地址(网络层阻塞)
> 4. 链路层:绑定mac节点->物理层
> 5. 物理层：把包发出去  
> .....  
> 完成第一次握手  
> ....  
> 不断发包收包，循环往复完成三次握手、资源开辟、数据传输、四次分手、资源释放    

shell
```shell script
# 查看网络状态(socket信息)
netstat -natp
```
###网关层(IP)
```shell script
# 查看0号网卡的配置
vi /etc/sysconfig/network-script/ifcfg-eth0
# ipV4地址，为点跟字节组成，两点之间是一个byte(字节)(8bit)表示的无符号十进制数(范围：0-255)。ip代表计算机编号
# IPADDR = 192.168.150.8
# 掩码，ip与掩码做二进制按位与运算，可得到网络号(网络目标)(192.168.150.0)
# NETMASK = 255.255.255.0
# 网关
# GATEWAY = 192.168.150.2

# 路由表(支持下一跳)
route -n
# 网络目标         网络掩码          网关           接口          跃点数
# 0.0.0.0         0.0.0.0          192.168.1.1    192.168.1.7  35
# 127.0.0.0       255.0.0.0        0.0.0.0        127.0.0.1    331
# 127.0.0.1       255.255.255.255  0.0.0.0        127.0.0.1    331  
# 127.255.255.255 255.255.255.255  0.0.0.0        127.0.0.1    331
# 192.168.1.0     255.255.255.0    0.0.0.0        192.168.1.7  291
# 192.168.1.7     255.255.255.255  0.0.0.0        192.168.1.7  291
# 192.168.1.255   255.255.255.255  0.0.0.0        192.168.1.7  291
# 224.0.0.0       240.0.0.0        0.0.0.0        127.0.0.1    331
# 网络目标:主机直连的局域网
# 网关(下一跳)：0.0.0.0表示与目标主机直连,连接不需要中间人。
# 目标IP地址(www.a.shifen.com [14.215.177.39])与路由表中每一条的掩码做二进制的按位与,
# 若得到目标与该条网络目标不一致则丢弃该条，继续计算路由表下一条记录。
# 若得到的目标与该条目的目标网络一致，则把数据包交给下一跳(该条目录的路由器网关)
``` 
**路由表的条目是怎么生成的：** 
第一条是通过网卡配置文件(ip/掩码)计算得来的，第二条是依据GATEWAY生成的(默认网关)。  

**数据包的目标IP地址应该放下一跳的IP地址还是原始IP地址?**
原始IP地址。链路层+映射表：在数据包上套下一跳的mac地址，交给交换机。下一条的路由收到包后打开发现目标IP不是自己，再做一次路由表运算，
套上对应的下一跳的mac地址交给交换机 


###链路层
```shell script
# 显示网关与mac地址的对应关系
arp
# 如果链路层不知到网关的mac地址，链路层会发一个arp广播（ping的包是icmp）
tcpdump -nn -i eth0 port 80 or arp
# 打印网关与mac地址映射表
arp -a
# 删除网关与mac地址映射表
arp -d
```