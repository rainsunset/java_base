OSI 7层参考模型|TCP/IP概念模型|关键词|。。。
---|---|---|---
应用层|应用层|HTTP、TFTP、SNMP、FTP、SMTP、DNS、telnet|
表示层|--|--|数据格式化、代码转换、数据集艾米
会话层|--|--|解除或建立与别的节点的联系
传输控制层|传输控制层|TCP、UDP|流量控制、数据分割、排序
网络层|网络层|IP|路由器
链路层|链路层|--|交换机
物理层|物理层|ISO02110、。。。|网卡；物理设备标准、传输比特流

TCP/IP协议模型  
应用层、传输控制层、网络层、链路层、物理层  
![TCP/IP协议模型](http://resource.cmbi.info/1a2ab07f-1461-4e41-8054-9d94cdecb9fb)


###应用层
shell演示: 1.向内核发送建立连接请求(三次握手) 2.发送数据(数据传输) 3.拿到响应(数据传输)（4.关闭连接(四次分手)）
```shell
# 与百度建立连接 exec:重定向 <>代表输入输出两个方向
exec 8<> /dev/tcp/www.baidu.com/80
# echo:打印 \n间隔请求头、请求体 空格用来做命令切割
#【协议：请求方法 、协议、协议版本 \n】【请求头(后面两个换行)：\n\n】 【请求体：】
# >&代表重定向，输出到8  8代表前面与baidu建立起来的连接
echo -e "GET / HTTP/1.0\n" >& 8
# cat:读取 <&代表从8读取
cat <& 8
# 关掉8这个链接
exec 8<& -
# 返回体结构
# 【协议：协议版本 状态code 状态\n】 【响应头(后面两个换行): \n\n】 【响应体：】
# nc：比telnet高级的设置路由命令
nc www.baidu.com 80
```
软件工程学的封装结果: webServer

**HTTP协议**


###传输(包)控制(连接)层(协议:UDP/TCP)  

#### TCP协议:  
> 是什么: 面向连接的可靠的基于字节流的传输层通信协议  
> 作用: 将应用层的数据流(依据MTU限制)分割成报文段(通过网络IP层)发送给目标节点的TCP层  
> 数据包都有序号(SeqNo)，对方收到则发送ACK确认，若(在RTT时间内)未收到确认，则会重传  
> 使用"校验和"来检验数据在传输过程中是否有误  

**shell演示：**  
```shell script
# tcpdump：抓包并打印
tcpdump -nn -i eth0 port 80
# 建立连接,tcpdump有包可抓
curl www.baidu.com
# 查看网络状态(socket信息)
netstat -natp
# 查看linux下各连接状态的连接数: linux下连接与文件句柄是一一对应的，如果CLOSE_WAIT状态的过多，意味着对应通道一直占用着
netstat -n | awk '/^tcp/{++S[$NF]}END{for(a in S) print a,S[a]}'
```

TOOLS: Wireshark、

**TCP报文头结构(20字节)**  

字节位数|2|2|4|4|0.5|0.5|1|2|2|2|可变
---|---|---|---|---|---|---|---|---|---|---|---
内容|source port|destination port|seq Number|ACK Number|offset|保留域|TCP Flags|windows|checkSUM(校验和)|Urgert Pointer|TCP Options

checkSUM: 是对TCP整个的报文段(包括TCP头部和TCP数据以16位计算所得，由发送端计算和存储并由接收端验证)  
seq num： 序号=上一报文段序号+上一报文段长度  
ack num: 期望收到下一个报文的序列号。= seqNum + 报文长度  
offset: 数据偏移(由于头部有可选字段，长度不固定)，指出tap报文数据离tap报文起始处有多远  
TCP Options: 可选项，长度可变，定义一些可选参数  
win: 滑动窗口,流量控制  
TCP Flags
> URG:紧急指针标志（1表示紧急指针有效 0表示忽略紧急指针）  
> **ACK:确认序号标志** （1表示确认号有效 0表示报文中不含确认信息，忽略确认号字段）  
> PSH:push标志（1表示为带有push标志的数据，接收方接收到带该标志的报文段后应该将这个报文段交给应用程序，而不是在缓冲区排队）  
> RST:重置连接标志（用于重置由于主机崩溃或其他原因出现的错误的连接，或用于拒绝非法的报文段和拒绝连接请求）  
> **SYN:同步序列号**（用于建立连接过程 SYN为1且ACK为0表示该数据段没有使用捎带的确认域 SYN为1且ACK为1表示...）    
> **FIN:finish标志**（用于释放连接 为1时表示数据发送放已经没有数据发送了）  

**连接**  
![三次握手建立连接](http://resource.cmbi.info/8982be50-7457-4374-97e4-3601d9770e41)  
0. client(closed)  -> server(closed) // 客户端和服务端都要创建传输控制块(Tcb)，服务端要进入listen状态  
1. c --\[SYN](SYN=1;seq=x)(不携带数据，但是要消耗掉一个序号)--> s // 客户端发送后进入同步已发送(SYN_SENT)的状态  
2. c <--\[SYN,ACK](SYN=1;ACK=1;seq=y,ack=x+1)(不携带数据,但消耗掉一个序列号)-- s // 服务端进入到SYN_RCVD的状态  
3. c --\[ACK](ACK=1;seq=x+1;ack=y+1)--> s // 给服务端确认报文。
seq是服务端期望的序列号(ack)，ack是服务端过来的序列号(seq)+1.此时连接建立，客户端进入ESTAB_LISHED状态，服务端收到请求后进入ESTAB-LISHED状态。  
4. c <--(开启数据传输)--> s  

第三次握手的必要性：初始化Seq的初始值  

未收到Client端的SYN服务端超时: Server端收到client的SYN，回复SYN-ACK后未收到Client的ACK报文。Server会不断重试直至超时。
(重试： linux下重试次数为5次，重试间隔为2的n-1次方秒，在第五次发出后要等待32秒后才算超时，合计63秒)  
超时隐患： 攻击者不断发SYN报文后立即断开连接使Server一直进入重连状态，将Server的SYN连接队列耗尽，让正常的连接连不上。  
针对SYN Flood的防护措施： 当SYN队列满了之后，Server端通过tcp_syncookies参数回发SYN Cookie。如果是攻击者就不会回应，正常连接会回发SYN Cookie，然后建立连接。  

TCP保活机制: 如Client端出现故障  
(在keepAliveTime内)开启保活功能的一端会向另一端方保活探测报文，如果未收到相应则依据配置的保活探测时间间隔继续发送，
直到发送报文的次数达到配置的保活探测数为止。测试对方主机将会被判定为不可达，连接也将会断开。  

连接的唯一性： ip+port+协议 (套接字/socket)   
socket(连接建立后在内核中存储socket信息，后面基于socket传输数据 socket的唯一性)：四元组：[ip+port ip+port]  

port(端口号)的取值范围：65535(2^16 - 1)(头部存储源端口号和目标端口号各占用16位)  
port分配原则:0 不使用；1–1023 系统保留,只能由root用户使用;1024—4999 由客户端程序自由分配;5000—65535 由服务器端程序自由分配  

三次握手以后，TCP将在两个应用程序之间建立一个全双工的通信,该通信将占用两个计算机之间的通信线路，直到被一方或双方关闭为止。  
全双工： 客户端可以给服务端发送数据，服务端也可以向客户端发送数据  

**断开连接**  
![四次分手](http://resource.cmbi.info/158ea83e-81bd-48ec-9657-621c73b85a03)  
0. client(ESTAB_LISHED)  -> server(ESTAB_LISHED) // 两个都处于ESTAB_LISHED状态，如客户端断开连接Then..  
1. c --\[FIN](FIN=1;seq=u)(不携带数据，但消耗掉1个序号)--> s // 客户端发出断开报文后进入FIN-WAIT-1状态，并且停止发送数据 u=之前传送数据的最后一个字节的序号+1  
2. c <--\[ACK](ACK=1;seq=v;ack=u+1)(不携带数据，但消耗掉一个序列号)-- s  // 服务端收到后发出确认报文，自己的序列号v,服务端此时进入CLOSE-WAIT的状态。
此时客户端已经没有数据发送了，但是服务端想要发送数据的话客户端还是可以接收的。
客户端收到此报文后进入FIN-WAIT-2的状态。等待服务端发送释放连接报文。  
3. c <--\[FIN,ACK](FIN=1;ACK=1;seq=w;ack=u+1)()-- s // 服务端在发送完数据后发送确认释放连接报文。状态变为LAST_ACK状态。
因为在客户端处于FIN-WAIT-2状态时，服务端有可能又发送了数据，所以服务端最后的序号为w。
ack还是u+1。  
4. c --\[ACK](ACK=1;seq=u+1;ack=w+1)--> s // 客户端在收到后发出出确认报文。此时客户端处于TIME_WAIT状态。客户端收到该报文后进入CLOSED状态。
发出该报文后客户端并不立即书房连接，要在TIME_WAIT状态等待2MSL后才能关闭连接(MSL:最长报文段寿命)  

为什么要在TIME_WAIT状态等待2MSL？  
1、确保对方有足够的时间收到ACK包。如果被动关闭的端(这里是服务端)没有收到ACK包会重发\[FIN,FIN]报文。 
2、避免新旧链接混淆。(有些路由会缓存数据包)  

四次握手断开连接的必要性： 因为TCP是全双工的，发送方和接收方都需要FIN报文和ACK报文。  

linux下出现大量CLOSE-WAIT状态的原因：对方关闭socket连接，我方忙于读或者写，没有及时关闭连接。  

**三次握手建立连接->http传输数据->四次分手断开连接是一个线性过程**  
> 1. 应用层申请建立连接->内核(应用层阻塞)
> 2. 内核-传输控制层准备握手的第一个包(控制包)->网络层(传输控制层阻塞)
> 3. 网络层(ip)：选择从哪个网卡哪个端口出去(找到(下一跳)网关地址)->向链路层请求网关mac地址(网络层阻塞)
> 4. 链路层:绑定mac节点->物理层
> 5. 物理层：把包发出去  
> .....  
> 完成第一次握手  
> ....  
> 不断发包收包，循环往复完成三次握手、资源开辟、数据传输、四次分手、资源释放    

#### UDP  
> 面向非连接
> 不维护连接状态
> 数据包报文头只有8字节，额外开销小
>
> 尽最大努力交付
> 面向报文的

**报文头结构(8字节)**

字节位数|0-15|16-31|32-47|48-63|
---|---|---|---|---|
内容|源端口|目标端口|length(数据包长度)|checksum

**与TCP的区别**  

区别点|TCP|UDP|
---|---|---
连接|面向连接|无连接
可靠性|有握手和重传机制可靠性优先保证|有可能丢失，不知道接收状态
有序性|利用序列号，到达可能无序，但最终会排序 | 不具备有序性
速度|慢，要做很多额外的事情|快
量级|重量级(报文头20字节)|轻量级(报文头8字节)


### 网关层(IP)
```shell script
# 查看0号网卡的配置
vi /etc/sysconfig/network-script/ifcfg-eth0
# ipV4地址，为点跟字节组成，两点之间是一个byte(字节)(8bit)表示的无符号十进制数(范围：0-255)。ip代表计算机编号
# IPADDR = 192.168.150.8
# 掩码，ip与掩码做二进制按位与运算，可得到网络号(网络目标)(192.168.150.0)
# NETMASK = 255.255.255.0
# 网关
# GATEWAY = 192.168.150.2

# 路由表(支持下一跳)
route -n
# 网络目标         网络掩码          网关           接口          跃点数
# 0.0.0.0         0.0.0.0          192.168.1.1    192.168.1.7  35
# 127.0.0.0       255.0.0.0        0.0.0.0        127.0.0.1    331
# 127.0.0.1       255.255.255.255  0.0.0.0        127.0.0.1    331  
# 127.255.255.255 255.255.255.255  0.0.0.0        127.0.0.1    331
# 192.168.1.0     255.255.255.0    0.0.0.0        192.168.1.7  291
# 192.168.1.7     255.255.255.255  0.0.0.0        192.168.1.7  291
# 192.168.1.255   255.255.255.255  0.0.0.0        192.168.1.7  291
# 224.0.0.0       240.0.0.0        0.0.0.0        127.0.0.1    331
# 网络目标:主机直连的局域网
# 网关(下一跳)：0.0.0.0表示与目标主机直连,连接不需要中间人。
# 目标IP地址(www.a.shifen.com [14.215.177.39])与路由表中每一条的掩码做二进制的按位与,
# 若得到目标与该条网络目标不一致则丢弃该条，继续计算路由表下一条记录。
# 若得到的目标与该条目的目标网络一致，则把数据包交给下一跳(该条目录的路由器网关)
``` 
**路由表的条目是怎么生成的：** 
第一条是通过网卡配置文件(ip/掩码)计算得来的，第二条是依据GATEWAY生成的(默认网关)。  

**数据包的目标IP地址应该放下一跳的IP地址还是原始IP地址?**
原始IP地址。链路层+映射表：在数据包上套下一跳的mac地址，交给交换机。下一条的路由收到包后打开发现目标IP不是自己，再做一次路由表运算，
套上对应的下一跳的mac地址交给交换机 


###链路层
```shell script
# 显示网关与mac地址的对应关系
arp
# 如果链路层不知到网关的mac地址，链路层会发一个arp广播（ping的包是icmp）
tcpdump -nn -i eth0 port 80 or arp
# 打印网关与mac地址映射表
arp -a
# 删除网关与mac地址映射表
arp -d
```