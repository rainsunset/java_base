JAVA数据类型
    基础数据类型
        ·数值型
            -整数类型
                byte:1byte 8bit -128至127 2^8
                short:2byte   -32768至32767
                int:4byte -2^31至2^31-1    -2147483648至2147483647 约21亿
                long：8byte    2^63至2^63-1 约9.22337203685E18(比long还大的是BigDecimina BigInteger)
            -浮点类型
                单精度类型(float) 4byte +-3.403E38
                    1bit(符号位 0表示正数,1表示负数)+8bits(指数位 底数是2)+23bits(尾数位)
                双精度类型(double) 8byte +-1.798E308
                    1bit(符号位)+11bits(指数位)+52bits(尾数位)
        字符型(char) 2byte
        布尔型(boolean) 1bit
    引用数据类型
        类(Class)（包含字符串类 String）
        接口(interface)
        数组([])
        枚举(enum)

浮点数保存原理>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    浮点数保存的字节格式如下：
    地址 +0 +1 +2 +3
    内容 SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM

    这里
        S 代表符号位，1是负，0是正
        E 偏移127的幂，二进制阶码=(EEEEEEEE)-127。
        M 24位的尾数保存在23位中，只存储23位，最高位固定为1。此方法用最较少的位数实现了较高的有效位数，提高了精度。

    零是一个特定值，幂是0 尾数也是0。

    浮点数-12.5作为一个十六进制数0xC1480000保存在存储区中，这个值如下：
    地址 +0 +1 +2 +3
    内容0xC1 0x48 0x00 0x00

    浮点数和十六进制等效保存值之间的转换相当简单。下面的例子说明上面的值-12.5如何转换。
    浮点保存值不是一个直接的格式，要转换为一个浮点数，位必须按上面的浮点数保存格式表所列的那样分开，例如：

    地址 +0 +1 +2 +3
    格式 SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM
    二进制 11000001 01001000 00000000 00000000
    十六进制 C1 48 00 00

    从这个例子可以得到下面的信息：
    符号位是1 表示一个负数
    幂是二进制10000010或十进制130，130减去127是3，就是实际的幂。
    尾数是后面的二进制数10010000000000000000000

    在尾数的左边有一个省略的小数点和1,这个1在浮点数的保存中经常省略,加上一个1和小数点到尾数的开头,得到尾数值如下:
    1.10010000000000000000000

    接着,根据指数调整尾数.一个负的指数向左移动小数点.一个正的指数向右移动小数点.因为指数是3,尾数调整如下:
    1100.10000000000000000000

    结果是一个二进制浮点数，小数点左边的二进制数代表所处位置的2的幂，例如：1100表示(1*2^3)+(1*2^2)+(0*2^1)+(0*2^0)=12。
    小数点的右边也代表所处位置的2的幂，只是幂是负的。例如：.100...表示(1*2^(-1))+(0*2^(-2))+(0*2^(-2))...=0.5。
    这些值的和是12.5。因为设置的符号位表示这数是负的，因此十六进制值0xC1480000表示-12.5。


float的指数范围为-2^7~2^7-1(即-128~127)，而double的指数范围为-2^10~2^10-1(即-1024~1023)，并且指数位是补码的形式来划分的。
其中负指数决定了浮点数所能表达的绝对值最小的数；而正指数决定了浮点数所能表达的绝对值最大的数，也即决定了浮点数的取值范围。
float和double的精度是由尾数的位数来决定的。浮点数在内存中是按科学计数法来存储的，其整数部分始终是一个隐含着的“1”，由于它是不变的，故不能对精度造成影响
float：2^23 = 8388608，一共七位，这意味着最多能有7位有效数字，但绝对能保证的为6位，也即float的精度为6~7位有效数字；
double：2^52 = 4503599627370496，一共16位，同理，double的精度为15~16位。

浮点数存在舍入误差，很多书字不能精确表示。如果需要进行不产生舍入误差的精确数字计算，需要使用BigDecimal类
最好避免比较中使用浮点数
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

2^0 1
2^1 2
2^2 4
2^3 8
2^4 16
2^7 128
2^8 256
2^15    32 768
2^16    65 536
2^31    2 147 483 648
2^32    4 294 967 296
2^63    9.22337203685E18
2^64    1.84467440737E19

用单引号表示字符 双引号为字符串
char类型是用来表示在unicode编码表中的字符
unicode编码被设计用来处理各种语言的所有文字，占用2个字符，可允许有65536个字符
Java 语言中还允许使用转义字符'\' 来将其后的字符转变为其他含义
char 是在0-65536范围 ， 运算时直接当做是整数来运算 可以把0-65536之间的整数直接转型为char char c = (char)99;//强制转型 -> 扩展 循环打印a-z
Unicode对照表：https://baike.baidu.com/item/ASCII/309296

基础类型相互转化
    自动转型：容量小的类型可以自动转为容量大的类型
        byte -> short -> int
                char  -> int
                         int -> long -(可能损失精度)-> double
                                     -(可能损失精度)-> float -> double
                         int -> double
                         int -(精度可能损失)-> float -> double

    强制转型 ：有可能造成精度境地或溢出  当一种类型强制转换成另一种类型而又超出了目标类型的表示范围，就会被阶段成为一个完全不同的值
    运算时结果会向容量大的类型提升
    运算结果溢出时会变成一个无意义的值 如int类型溢出时会变成负值
    整数数字默认int型(-128-127自动拆箱)，小数数字默认double。
    += 与 ++ 与 + : short a = 1; a = a+1 会报错因为1是int类型; a+=1; 相当于不会报错，相当于 a = (short)(a+1); a++当然也不会;

    例：计算一个人70年心跳次数
        long l = 70L*60*24*365*70;
        //若不把第一个70转化成long类型 计算结果则会溢出


进制计算
    二进制(Binary):
    java中0b开头表示二进制数 可用下划线分割 下划线分隔符同样适用于十进制

反码
补码

数组
    数组默认初始化：数组元素相当于对象的成员变量，默认值跟成员变量的规则一样

Java中除了基本类型外的变量类型都称为引用类型，java中的对象是通过引用（reference）对其操作的
    java中默认初始化：数值：0,,0.0  char:\u0000 boolean:false 引用类型：null

内存分析：
    栈：存放局部变量
    堆：存放new出来的对象
    方法区：存放 类的代码 static变量 常量池等
