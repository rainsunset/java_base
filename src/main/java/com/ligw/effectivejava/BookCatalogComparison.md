## 资源

* [effective-java-2nd 中文版 ](https://pan.baidu.com/s/1R6H9UHbFYubWWY9HrclZ2A)
* [effective-java-3rd 英文版 ](https://pan.baidu.com/s/1mJx5ZrOD_RPjf3ghQnBV5g)
* [effective-java-3rd 源代码](https://github.com/jbloch/effective-java-3e-source-code)

## 目录对照

| 📚 高效 Java 第三版     | 📚 高效 Java 第二版 |   
| :---  | :--- |
| Chapter 2. Creating and Destroying Objects | 第2章 创建和销毁对象 |
| [01. 考虑使用静态工厂方法替代构造方法]() | [第1条：考虑用静态工厂方法代替构造器]() |
| [02. 当构造方法参数过多时使用builder模式]() | [第2条：遇到多个构造器参数时要考虑用构建器]() |
| [03. 使用私有构造方法或枚类实现Singleton属性]() | [第3条：用私有的构造器或者枚举类型强化Singleton属性]() |
| [04. 使用私有构造方法执行非实例化]() | [第4条：通过私有构造器强化不可实例化的能力]() |
| [05. 依赖注入优于硬连接资源(hardwiring resources)]() | []() |
| [06. 避免创建不必要的对象]() | [第5条：避免创建不必要的对象]() |
| [07. 消除过期的对象引用]() | [第6条：消除过期的对象引用]() |
| [08. 避免使用Finalizer和Cleaner机制]() | [第7条：避免使用终结方法]() |
| [09. 使用try-with-resources语句替代try-finally语句]() | []() |
| Chapter 3. Methods Common to All Objects | 第3章 对于所有对象都通用的方法 |
| [10. 重写equals方法时遵守通用约定]() | [第8条：覆盖equals时请遵守通用约定]() |
| [11. 重写equals方法时同时也要重写hashcode方法]() | [第9条：覆盖equals时总要覆盖hashCode]() |
| [12. 始终重写 toString 方法]() | [第10条：始终要覆盖toString]() |
| [13. 谨慎地重写 clone 方法]() | [第11条：谨慎地覆盖clone]() |
| [14. 考虑实现Comparable接口]() | [第12条：考虑实现Comparable接口]() |
| Chapter 4. Classes and Interfaces | 第4章 类和接口 |
| [15. 使类和成员的可访问性最小化]() | [第13条：使类的成员的可访问性最小化]() |
| [16. 在公共类中使用访问方法而不是公共属性]() | [第14条：在公有类中使用访问方法而非公有域]() |
| [17. 最小化可变性]() | [第15条：使可变性最小化]() |
| [18. 组合优于继承]() | [第16条：复合优于继承]() |
| [19. 要么设计继承并提供文档说明，要么禁用继承]() | [第17条：要么为继承而设计，并提供文档说明，要么就禁止继承]() |
| [20. 接口优于抽象类]() | [第18条：接口优于抽象类]() |
| [21. 为后代设计接口]() | []() |
| [22. 接口仅用来定义类型]() | [第19条：接口只用于定义类型]() |
| [23. 类层次结构优于标签类]() | [第20条：类层次优于标签类]() |
| [24. 支持使用静态成员类而不是非静态类]() | []() |
| [25. 将源文件限制为单个顶级类]() | []() |
| []() | [第21条：用函数对象表示策略]() |
| []() | [第22条：优先考虑静态成员类]() |
| Chapter 5. Generics | 第5章 泛型 |
| [26. 不要使用原始类型]() | [第23条：请不要在新代码中使用原生态类型]() |
| [27. 消除非检查警告]() | [第24条：消除非受检警告]() |
| [28. 列表优于数组]() | [第25条：列表优先于数组]() |
| [29. 优先考虑泛型]() | [第26条：优先考虑泛型]() |
| [30. 优先使用泛型方法]() | [第27条：优先考虑泛型方法]() |
| [31. 使用限定通配符来增加API的灵活性]() | [第28条：利用有限通配符来提升API的灵活性]() |
| [32. 合理地结合泛型和可变参数]() | []() |
| [33. 优先考虑类型安全的异构容器]() | [第29条：优先考虑类型安全的异构容器]() |
| Chapter 6. Enums and An) | 第6章 枚举和注解 |
| []() | [第30条：用enum代替int常量]() |
| [35. 使用实例属性替代序数]() | [第31条：用实例域代替序数]() |
| [36. 使用EnumSet替代位属性]() | [第32条：用EnumSet代替位域]() |
| [37. 使用EnumMap替代序数索引]() | [第33条：用EnumMap代替序数索引]() |
| [38. 使用接口模拟可扩展的枚举]() | [第34条：用接口模拟可伸缩的枚举]() |
| [39. 注解优于命名模式]() | [第35条：注解优先于命名模式]() |
| [40. 始终使用Override注解]() | [第36条：坚持使用Override注解]() |
| [41. 使用标记接口定义类型]() | [第37条：用标记接口定义类型]() |
| Chapter 7. Lambdas and Streams |  |
| [42. lambda表达式优于匿名类]() | []() |
| [43. 方法引用优于lambda表达式]() | []() |
| [44. 优先使用标准的函数式接口]() | []() |
| [45. 明智审慎地使用Stream]() | []() |
| [46. 优先考虑流中无副作用的函数]() | []() |
| [47. 优先使用Collection而不是Stream来作为方法的返回类型]() | []() |
| [48. 谨慎使用流并行]() | []() |
| Chapter 8. Methods | 第7章 方法 |
| [49. 检查参数有效性]() | [第38条：检查参数的有效性]() |
| [50. 必要时进行防御性拷贝]() | [第39条：必要时进行保护性拷贝]() |
| [51. 仔细设计方法签名]() | [第40条：谨慎设计方法签名]() |
| [52. 明智审慎地使用重载]() | []() |
| [53. 明智审慎地使用可变参数]() | []() |
| [54. 返回空的数组或集合，不要返回 null]() | [第43条：返回零长度的数组或者集合，而不是null]() |
| [55. 明智审慎地返回 Optional]() | []() |
| [56. 为所有已公开的 API 元素编写文档注释]() | [第44条：为所有导出的API元素编写文档注释]() |
| Chapter 9. General Programming
| [57. 最小化局部变量的作用域]() | [第45条：将局部变量的作用域最小化]() |
| [58. for-each 循环优于传统 for 循环]() | [第46条：for-each循环优于传统的for循环]() |
| [59. 了解并使用库]() | [第47条：了解和使用类库]() |
| [60. 若需要精确答案就应避免使用 float 和 double 类型]() | [第48条：如果需要精确的答案，请避免使用float和double]() |
| [61. 基本数据类型优于包装类]() | [第49条：基本类型优先于装箱基本类型]() |
| [62. 当使用其他类型更合适时应避免使用字符串]() | [第50条：如果其他类型更适合，则尽量避免使用字符串]() |
| [63. 当心字符串连接引起的性能问题]() | [第51条：当心字符串连接的性能]() |
| [64. 通过接口引用对象]() | [第52条：通过接口引用对象]() |
| [65. 接口优于反射]() | [第53条：接口优先于反射机制]() |
| [66. 明智审慎地本地方法]() | [第54条：谨慎地使用本地方法]() |
| [67. 明智审慎地进行优化]() | [第55条：谨慎地进行优化]() |
| [68. 遵守被广泛认可的命名约定]() | [第56条：遵守普遍接受的命名惯例]() |
| Chapter 10. Exceptions
| [69. 只针对异常的情况下才使用异常]() | []() |
| [70. 对可恢复的情况使用受检异常，对编程错误使用运行时异常]() | []() |
| [71. 避免不必要的使用受检异常]() | []() |
| [72. 优先使用标准的异常]() | []() |
| [73. 抛出与抽象对应的异常]() | []() |
| [74. 每个方法抛出的异常都需要创建文档]() | []() |
| [75. 在细节消息中包含失败一捕获信息]() | []() |
| [76. 保持失败原子性]() | []() |
| [77. 不要忽略异常]() | []() |
| Chapter 11. Concurrency
| [78. 同步访问共享的可变数据]() | []() |
| [79. 避免过度同步]() | []() |
| [80. executor 、task 和 stream 优先于线程]() | []() |
| [81. 并发工具优于 wait 和 ) | []() |
| [82. 文档应包含线程安全属性]() | []() |
| [83. 明智审慎的使用延迟初始化]() | []() |
| [84. 不要依赖线程调度器]() | []() |
| Chapter 12. Serialization
| [85. 优先选择 Java 序列化的替代方案]() | []() |
| [86. 非常谨慎地实现 Serializable]() | []() |
| [87. 考虑使用自定义的序列化形式]() | []() |
| [88. 保护性的编写 readObject 方法]() | []() |
| [89. 对于实例控制，枚举类型优于 readResolve]() | []() |
| [90. 考虑用序列化代理代替序列化实例]() | []() |

